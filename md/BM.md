# BM算法 Boyer-Moore 

BM算法也是字符串匹配的一个算法，它是BF算法的改进。时间复杂度为 `O(m+n)`，效率比 KMP算法高3-5倍。 

这是demo --> [٩(∗ ›ω‹ ∗)و](https://github.com/yuyilei/Algorithms/blob/master/C%2B%2B/BM.cpp)

BM算法实际上是两个并行的算法：坏字符算法和好后缀算法。

BM算法通过后缀匹配，就是指模式串从右到左匹配。在匹配的过程中，一但匹配不成功，就要重新移动下标，BM算法唯一改变的就是移动下标的过程。 

先来了解几个概念： 

**坏字符** ： 当模式串和原串的字符并不匹配时，原串中的字符称为坏字符。（注意：是原串中的字符叫 坏字符）

**好后缀** ： 模式串和原串中相等后缀。如，原缀：1234512345， 模式：23。 好后缀就是23 和 3 。

BM算法不匹配时向右移动的距离就是 **坏字符算法** 和 **好后缀算法** 的最大值。 

## 坏字符算法

当模式从右到左匹配遇到坏字符时，分为两种情况。 

1） 坏字符没有出现模式中。 

此时，只要将下标j(这个下标j是在原串中循环的变量)移动到 坏字符的下标的下一位。 因为反正模式中不存在这个坏字符，就直接一股脑移过去。 

2） 坏字符出现在模式中。

此时，需要将下标j(这个下标也是原串中的循环遍量)移动，使得原串中的坏字符和模式中最右边的坏字符对齐。 

所以，遇到坏字符，移动的距离：  坏字符在原串中的位置（下标） - 坏字符在模式中上次出现的位置（如果坏字符没有出现在模式中位置就为-1） 

代码如下： 

```
/* 
BmGc数组就是 每个字符 （ ascii码从 0到255的字符） 到模式尾部的最短长度（所以从左向右移动，这样的得到的一定是最短距离）。 
如果 ascii为0到255中的某个字符不在模式中，最短长度就是模式本身的长度。   
*/
void getBmGc(char *T, int tlen ) {
    for ( int i = 0 ; i < 256 ; i++ ) 
        BmGc[i] = tlen ;                                // 先把 0 到 255 的字符 都初始化为 模式的长度 
    for ( int i = 0 ; i < tlen ; i++ ) 
        BmGc[T[i]] = tlen - 1 - i ;                     // 计算 模式中 每个字符 到字符串尾部的长度 。 
} 
```

## 好后缀算法 

好后缀算法在不匹配时，有3种情况：

1） 模式中存在子串 与 好后缀匹配。

此时。移动模式串，让子串和好后缀对齐即可，如果超过一个子串匹配上好后缀，则选择最靠左边的子串对齐。 

2）模式串中没有子串匹配上好后缀。

此时，寻找模式串中的一个和好后缀（子串）相等的最长前缀，并让该前缀和好后缀对齐。 

3）模式串中没有子串匹配上好后缀，并且在模式串中找不到和好后缀（子串）相等的最长前缀（最长前缀的长度为0）。

此时，移动模式到好后缀的下一个字符。 

综上： 

好后缀算法移动的距离 ： 好后缀的位置 - 好后缀与模式中的最长前缀（完全匹配时，最长前缀就是好后缀本身）在模式中出现的位置。

代码如下： 

```
/*
    suff数组： suff[i] = 以i为右边界，与模式串后缀匹配的最大长度。 
*/ 
    void getsuff(char *T, int tlen) {
        suff[tlen-1] = tlen ;                        //   suff[tlen-1] 等于自身的长度本身。 
        for ( int i = tlen - 2 ; i >= 0 ; i-- ) {
            int tmp = i ; 
            while ( tmp >= 0 && T[tmp] == T[tlen-1-i+tmp] ) 
                tmp-- ; 
            suff[i] = i - tmp ; 
        }
    }

/*
 三种情况：
 1.模式串中有子串匹配上好后缀
 2.模式串中没有子串匹配上好后缀，但找到一个最大前缀
 3.模式串中没有子串匹配上好后缀，且找不到一个最大前缀

 处理的顺序：
 3->2->1 
*/

    void getBmGs(char *T, int tlen) {
        getsuff() ; 
        for ( int i = 0 ; i < tlen ; i++ )                // 处理第三种情况，没有子串匹配好后缀，且没有最大前缀，就直接移动整个模式的长度。 
            BmGs[i] = tlen ; 

        int j = 0 ; 
        for ( int i = tlen - 1 ; i >= 0 ; i-- ) {        // 处理第二种情况，没有子串匹配好后缀，但是找到了最大前缀，
            if ( suff[i] == i+1 )                        // 这个条件就是 找到了最大前缀 。 
                for ( ; j < tlen - 1 - i ; j++ )         // 把这个区间中的BmGs都改。 
                    if ( BmGs[j] == tlen )               // 这个标记是为了每个位置只改变一次。
                        BmGs[j] = tlen - i - 1 ; 
        }

        for ( int i = 0 ; i <= tlen - 2 ; i++ )          // 处理第一种情况。 有子串与好后缀匹配。
            BmGs[tlen-1-suff[i]] = tlen - i - 1 ;        // i表示的是以i开始往右的子串，从该位置要移动到最后一个位置，距离是tlen-i-1  
                                                         // suff[i]等于好后缀的长度，所以 tlen-1-suff[i]是好前缀的前一个字符位置
    } 
```

## 匹配函数

然后就是匹配过程，代码如下：

```
    void bm() {
        getBmGc() ; 
        getBmGs() ;     
        int i, j, flag = 0 ; 
        for ( j = 0 ; j <= slen - tlen ; ) {
            for ( i = tlen - 1 ; i >= 0 && S[j+i] == T[i] ; i-- )        //  从右往左匹配，遇到不匹配的情况，就退出
                ;
            if ( i < 0 ) {                                               // i < 0 表示匹配完成 
                printres(j) ;
                j += BmGs[0] ;  
                flag = 1 ;  
            } 
            else {
                j += max(BmGs[i],BmGc[S[i+j]]-(tlen-1-i)) ;                // 匹配不完成，改变j , 取好后缀和坏字符的最大值。 
            }                                                              // tlen-i-1是i到模式尾部的距离，BmGc[S[i+j]]是坏字符到模式                                                                // 尾部的距离，两者相减，就是移动的距离。
        }
        if ( flag == 0 ) 
            printf("子串在主串中不匹配!\n") ; 
    }

    void printres(int index) {
        printf("子串在主串下标 %d 处匹配!\n",index) ; 
    }
```