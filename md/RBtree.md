# 红黑树
红黑树(Red-Black Tree，简称R-B Tree)，它一种特殊的**二叉查找树**。

红黑树的应用比较广泛，主要是用它来存储有序的数据。C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。

nginx中的定时器也是放在一棵红黑树中维护的。

### 红黑树概念
**二叉查找树**： 
1. 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
2. 若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
3. 任意节点的左、右子树也分别为二叉查找树；
4. 没有键值相等的节点。

**红黑树**
红黑树属于二叉查找树，也有二叉查找树的所有特点，除此之外，红黑树还有以下特点：
1.  每个节点是黑色，或者是红色。
2. 根节点是黑色。
3. 每个叶子节点是黑色。（这里叶子节点，是指为空的叶子节）
4. 如果一个节点是红色的，则它的子节点必须是黑色的。
5. 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。

特点5确保了从根到叶子的最长路径不会超过最短路径的2倍，所以红黑树是**接近平衡**的二叉树。


### 红黑树特点
#### 时间复杂度为: O(lgn)
**定理1**：一棵含有n个节点的红黑树的高度至多为2log(n+1)。

黑高度：从某个节点x出发（不包括该节点）到达一个叶节点的任意一条路径上，黑色节点的个数称为该节点的黑高度(x's black height)，记为**bh(x)**。

**定理1**等价于： 高度为h的红黑树，它的包含的内节点个数至少为 2^(**bh(x)**)-1。

红黑树的插入删除操作的时间复杂度都是 O(logn), 且修复红黑树的过程中最多旋转三次。

### 红黑树的构建和插入
构建红黑树的过程就是一个个节点插入的过程。 
这是构建一棵红黑树的demo --> [红黑树构建](https://github.com/yuyilei/Algorithms/blob/master/C%2B%2B/insert-red-and-black-tree.cpp)

构建红黑树的过程就是：

1）把红黑树当作普通的二叉查找树树，插入当前节点。

2）将插入完成的树修复为红黑树。 

值得注意的是：每一个插入的节点应该是红色的，根据红黑树的特点5，**一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点**，如果插入黑色节点就会破坏这个特性。 

但是，插入红色节点可能会破坏特点4，**如果一个节点是红色的，则它的子节点必须是黑色的**。此时就需要通过**旋转**和**变色**来修复红黑树。 

修复红黑树时，根据当前节点的**父节点**分为以下3中情况：

1） 父节点为空，则当前节点为根节点，将当前节点设置为黑色，修复完成。

2） 父节点不为空且为黑色，此时不需修复，插入红色节点之后，仍然时红黑树。

3） 父节点不为空且为红色，与红黑树的特性5相冲突。这种情况下，被插入节点是一定存在**非空祖父节点**的;根据父节点是祖父节点的左孩子还是右孩子分为两种情况：
    
    a. 父节点是祖父节点的左孩子。
    
    b. 父节点是祖父节点的右孩子。 
    
    进一步的讲，被插入节点也一定存在**叔叔节点**(即使叔叔节点为空，也视之为存在，空节点本身就是黑色节点)。依据**叔叔节点**的情况，上面的两种情况的每一种又进一步划分为3种情况。
    
        case1. 父节点是红色，叔叔节点存在，且是红色。
        
        case2. 父节点是红色，叔叔节点不存在或者为黑色，当前节点是父节点的右孩子。
        
        case3. 父节点是红色，叔叔节点不存在或者为黑色，当前节点是父节点的左孩子。 

所以根据**父节点与祖父节点的关系**和**叔叔节点**的情况，将情况分为6种。

处理的核心思路是：**将红色的节点移到根节点，然后，将根节点设为黑色**。 

总的来说，处理问题的时候，需要从下至上(由叶到根)方向进行处理；也就是说，必须先解决“儿子”的问题，再解决“父亲”的问题，最后逼近根节点，将根节点设为黑色。


